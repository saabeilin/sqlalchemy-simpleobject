from collections import OrderedDict
from datetime import datetime, timedelta
from decimal import Decimal

from sqlalchemy.orm import object_session
from sqlalchemy.orm.collections import InstrumentedList

__author__ = 'sbeilin'


def simple_object(objekt, attrs=None, level=0, maxdepth=2, short=False):
    """ Returns a Simple Object representation
    @param objekt   object to "simplify"
    @param attrs
    @param level
    @param maxdepth
    @param short
    @return SimpleObject representation of 'objekt'
    """

    if hasattr(objekt, 'simple_object'):
        return objekt.simple_object(attrs, level=level + 1, maxdepth=maxdepth, short=short)

    # print objekt.__class__

    if objekt is None:
        return objekt
    elif isinstance(objekt, (bool, int, float)):
        return objekt
    elif isinstance(objekt, Decimal):
        return float(objekt)
    elif isinstance(objekt, datetime):
        try:
            return (objekt - datetime.utcfromtimestamp(0)).total_seconds()
        except:
            return 0
    elif isinstance(objekt, timedelta):
        try:
            return int(objekt.total_seconds())
        except:
            return 0
    # elif isinstance(objekt, InstrumentedList):
    #     return [v.id for v in objekt]
    elif isinstance(objekt, dict):
        return {k: simple_object(v, level=level + 1, maxdepth=maxdepth, short=short)
                for k, v in objekt.items()}
    elif isinstance(objekt, (list, tuple, InstrumentedList)):
        return [simple_object(v, level=level + 1, maxdepth=maxdepth, short=short)
                for v in objekt]
    else:
        return str(objekt)


class SimpleObjectMixin(object):
    def simple_object(self, attrs=None, level=0, maxdepth=2, short=False):
        """ Returns a Simple Object representation
        """
        obj = OrderedDict(type=self.__class__.__name__)

        keys = None

        autogenerated = False
        if short:
            if hasattr(self, '_json_attrs_short'):
                keys = self._json_attrs_short
            elif hasattr(self, '_json_attrs'):
                keys = self._json_attrs
            # else:
            #     keys = ('id',)
            else:
                keys = list(self.__dict__.keys())
        elif attrs:
            keys = attrs
        elif hasattr(self, '_json_attrs'):
            keys = self._json_attrs
        else:
            keys = list(self.__dict__.keys())
            autogenerated = True

        # filter(lambda x: x[0]!='_', self.__class__.__dict__.keys())
        # self.__table__.c.keys() #self.__dict__.keys()

        for name in keys:  # self.table.c.keys():
            if name[0] == '_':
                continue

            if not hasattr(self, name):
                # obj[name] = None
                continue

            value = getattr(self, name)
            if value is None:
                obj[name] = None
                continue

            if isinstance(value, InstrumentedList):
                if autogenerated or level > maxdepth:
                    continue

            obj[name] = simple_object(value,
                                      level=level + 1, maxdepth=maxdepth,
                                      short=short)

        return obj

    def update(self, dikt, set_nones=False):
        """Update current object from given dictionary"""
        for k, v in dikt.items():
            if k[0] == '_':
                continue
            if v is None and not set_nones:
                continue

            # getattr(c.__class__, 'advertisers').mapper.class_

            if v is None and isinstance(getattr(self, k), InstrumentedList):
                setattr(self, k, [])
            elif isinstance(v, list) and isinstance(getattr(self, k), InstrumentedList):
                rel_cls = getattr(self.__class__, k).mapper.class_
                rel_objs = object_session(self).query(rel_cls).filter(rel_cls.id.in_(v)).all()
                setattr(self, k, rel_objs)
            else:
                setattr(self, k, v)
